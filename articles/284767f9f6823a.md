---
title: "構築済みのaws環境をterraform化できたのでtipsを紹介したい"
emoji: "⛳"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["aws", "terraform"]
published: false
---
この記事には一部AI生成している箇所があります。
## はじめに
業務でAWS環境をコンソール内で構築したのですが、terraformでコード管理できるようにしたいという要望があり、terraform化することになりました。
AWSの経験3ヶ月くらい、terraformは未経験ながら、なんとかterraform化にこぎつけることができました。そのときに便利だと感じたtipsを紹介します。

## importについて
既存のawsリソースをterraform化するにはimportという作業が必要です。

## terraform importコマンド
terraform1.5以前から使用できるimport方法です。
コマンドを使って既存リソースをimportします。

あらかじめtfファイルにresourceブロックを作成します。

```hcl
# example.tf
resource "aws_s3_bucket" "example" {
  bucket = "my-existing-bucket"
  acl    = "private"
}
```

そのresourceに対してterraform importコマンドを実行します。
importコマンドを実行すると、tfstateが保存されます。

```bash
terraform import aws_s3_bucket.example my-existing-bucket
```

その後、resourceブロックを編集してterraform planを実行しながらtfstateとの差分を埋めていきます。

```bash
terraform plan
```

## importブロック
今回はこの方法でimportを行いました。terraformのバージョン1.5以上で動作可能です。
importしたいリソースのimportブロックをimport.tfに作成します。

```hcl
import {
  to = aws_s3_bucket.example
  id = "my-existing-bucket"
}
```

### terraform plan
importブロックの場合、`terraform import`コマンドではなく`terraform plan`を実行します。importコマンドのように実行後tfstateが作られることはないです。なのでplan結果に問題がなければapplyをしてtfstateを作成する必要があります。

import方法によってはさらにコマンドのオプションを指定することも可能です。

#### -generate-config-outオプションによる自動生成

```bash
terraform plan -generate-config-out=generated.tf
```

このオプションを付与することでimportしたいリソースが自動生成されます。

```hcl
# generated.tf (例、実際は terraform が生成)
resource "aws_s3_bucket" "example" {
  bucket = "my-existing-bucket"
  acl    = "private"

  # terraform が自動で拾ってきた属性が多く含まれることがあるため、
  # 不要な属性は削除し、変数化やモジュール化を検討する
  tags = {
    "Name" = "my-existing-bucket"
  }
}
```

大変便利ですが、冗長なデータなので適宜変数化やモジュール化を行う必要があります。
まったくの0からリソースをterraform化するのに使えると思います。

#### オプションなし

オプションを指定しない場合、自動生成はされないです。しかし、resourceブロックをあらかじめ定義している必要があります。

import.tf:
```hcl
import {
  to = aws_s3_bucket.example
  id = "my-existing-bucket"
}
```

example.tf (事前に最低限の属性を記載しておく):
```hcl
resource "aws_s3_bucket" "example" {
  bucket = "my-existing-bucket"
  acl    = "private"
  # 必要に応じて以下のような属性を追加しておくと差分が少なくなる
  # force_destroy = false
  # versioning {
  #   enabled = false
  # }
}
```

`terraform import`コマンドと雰囲気は同じですが、applyしない限りtfstateは保存されません。なので、planの実行結果を参考にしながら、resourceブロックの定義をして差分を埋めていくことになります。

```bash
# plan結果を見ながらresourceを構成して差分を埋めていく
terraform plan
```

この方法は、すでに変数化やモジュール化が済んだterraformに対して別環境を作成するとき、例えば開発環境は済んでいて、そこから本番環境に展開したい。というときに大活躍します。

## terraform_remote_state
terraform化したリソースたちに依存関係を持たせるために使います。
例えばECSのtask_definitionを定義する時にtaskExecutionRoleとtaskRoleに対象となるiamのarnをiamのremote_stateを作成することでiamのarnを変数化するという感じです。

iamの情報を他リソースで共有するために、iamにoutputブロックを作成します。

```hcl
# filepath: iam/outputs.tf
output "task_role_arn" {
  value       = aws_iam_role.task_role.arn
  description = "ARN of the ECS task role"
}

output "task_execution_role_arn" {
  value       = aws_iam_role.task_execution_role.arn
  description = "ARN of the ECS task execution role"
}
```

outputを作成したら、一度`terraform apply`をしてtfstateにoutputを登録させる必要があります。

```bash
# 実行計画の確認
terraform plan
# 問題なければapply
terraform apply
```

ECSにiamのremote_stateブロックを作成します。
remote_stateを経由することで、iamの情報をECSは受け取ることができます。

```hcl
# filepath: ecs/main.tf
data "terraform_remote_state" "iam" {
  backend = "s3"
  config = {
    bucket = "my-terraform-state-bucket"
    key    = "iam/terraform.tfstate"
    region = "ap-northeast-1"
  }
}

resource "aws_ecs_task_definition" "app" {
  family                   = "app-task"
  task_role_arn            = data.terraform_remote_state.iam.outputs.task_role_arn
  execution_role_arn       = data.terraform_remote_state.iam.outputs.task_execution_role_arn
  network_mode             = "awsvpc"
  requires_compatibilities = ["FARGATE"]

  container_definitions = jsonencode([
    {
      name  = "app"
      image = "amazonlinux:2"
      cpu   = 256
      memory = 512
      essential = true
      portMappings = [{ containerPort = 80, hostPort = 80 }]
    }
  ])
}
```

## state管理
tfstateの確認をするときに使うコマンドを紹介します。

### state show
既存ステート内のリソースの詳細を表示します。リソースの属性確認や、import後の確認に便利です。

```bash
# 例: S3 バケットのステート詳細を表示
terraform state show aws_s3_bucket.example
```

出力の一部（例）:
```
id = my-existing-bucket
arn = arn:aws:s3:::my-existing-bucket
bucket = my-existing-bucket
acl = private
...
```

### state list
現在の tfstate に登録されている全リソースのアドレス一覧を取得します。

```bash
terraform state list
# 出力例:
# aws_s3_bucket.example
# aws_iam_role.task_role
# module.ecs.aws_ecs_task_definition.app
```

### state rm
tfstate からリソースを削除します。コンソール上から実際にリソースが削除されるわけではなく、あくまでtfstateの管理から離すだけです。

```bash
# 例: tfstate から削除
terraform state rm aws_s3_bucket.example
```

用途の例:
- 誤って import してしまったリソースを state から外す
- 外部管理に移行するリソースの state を切り離す

### state mv
resourceの名前を変更した際、紐づいているtfstateのリソース名も変更するのに使います。

```bash
terraform state mv aws_s3_bucket.example aws_s3_bucket.renamed_example
```

### movedブロック
上記の`terraform state mv`と用途は同じです。しかし、このブロックのいいところはリネームの履歴をコード上に残せるところです。

```hcl
# 例: moved ブロック
moved {
  from = aws_s3_bucket.example
  to   = aws_s3_bucket.renamed_example
}
```